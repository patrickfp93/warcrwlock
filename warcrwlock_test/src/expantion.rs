// ðŸ¦€ Generated by Rust Macro Expand ðŸ¦€
// ðŸ¦€ Timestamp: 23/02/2024, 15:51:34  ðŸ¦€

pub mod generics_with_trait {
    use warcrwlock::warcrwlock;
    pub trait A {}
    pub type SCore<T: A> = _core::S<T>;
    use std::{
        fmt::Debug, ops::{Deref, DerefMut},
        sync::{Arc, RwLock, RwLockReadGuard, RwLockWriteGuard},
    };
    mod _core {
        use super::*;
        #[doc(hidden)]
        pub struct S<T: A> {
            pub(super) a: T,
            pub(super) b: Vec<f64>,
            pub(super) c: f64,
        }
    }
    #[repr(C)]
    pub struct S<T: A> {
        _core: Arc<RwLock<SCore<T>>>,
    }
    impl<T: A> S<T> {
        fn a_mut(&mut self) -> SMutLock<T, T> {
            let mut guard = self._core.write().unwrap();
            let value = &mut guard.a;
            let value = (value as *const T) as *mut T;
            return SMutLock::new(value, guard);
        }
        fn a(&self) -> SRefLock<T, T> {
            let guard = self._core.read().unwrap();
            let value = &guard.a;
            let value = value as *const T;
            return SRefLock::new(value, guard);
        }
        fn b_mut(&mut self) -> SMutLock<Vec<f64>, T> {
            let mut guard = self._core.write().unwrap();
            let value = &mut guard.b;
            let value = (value as *const Vec<f64>) as *mut Vec<f64>;
            return SMutLock::new(value, guard);
        }
        fn b(&self) -> SRefLock<Vec<f64>, T> {
            let guard = self._core.read().unwrap();
            let value = &guard.b;
            let value = value as *const Vec<f64>;
            return SRefLock::new(value, guard);
        }
        fn c_mut(&mut self) -> SMutLock<f64, T> {
            let mut guard = self._core.write().unwrap();
            let value = &mut guard.c;
            let value = (value as *const f64) as *mut f64;
            return SMutLock::new(value, guard);
        }
        fn c(&self) -> SRefLock<f64, T> {
            let guard = self._core.read().unwrap();
            let value = &guard.c;
            let value = value as *const f64;
            return SRefLock::new(value, guard);
        }
        fn builder(a: T, b: Vec<f64>, c: f64) -> Self {
            return SCore::<T> { a, b, c }.into();
        }
    }
    impl<T: A> S<T> {
        pub fn extract(&self) -> SCore<T> {
            self.clone().into()
        }
    }
    impl<T: A> From<S<T>> for SCore<T> {
        fn from(wrapper: S<T>) -> Self {
            let guard = wrapper._core.write().unwrap();
            let ptr = &*guard as *const SCore<T>;
            let reply = unsafe { std::ptr::read(ptr) };
            drop(guard);
            return reply;
        }
    }
    impl<'a, T: A> From<SCore<T>> for S<T> {
        fn from(_core: SCore<T>) -> Self {
            return Self {
                _core: Arc::new(RwLock::new(_core)),
            };
        }
    }
    impl<T: A> PartialEq for S<T> {
        fn eq(&self, other: &Self) -> bool {
            let ptr_number = self._core.as_ref() as *const RwLock<SCore<T>> as usize;
            let other_ptr_number = other._core.as_ref() as *const RwLock<SCore<T>>
                as usize;
            return ptr_number == other_ptr_number;
        }
    }
    impl<T: A> Clone for S<T> {
        fn clone(&self) -> Self {
            return Self { _core: self._core.clone() };
        }
    }
    unsafe impl<T: A> Send for S<T> {}
    unsafe impl<T: A> Sync for S<T> {}
    impl<T: A> S<T> {
        fn into_vec_wrapper(bases: Vec<SCore<T>>) -> Vec<S<T>> {
            bases.into_iter().map(|b| b.into()).collect()
        }
        fn into_vec_base(multiples: Vec<S<T>>) -> Vec<SCore<T>> {
            multiples.iter().map(|w| (*w).clone().into()).collect()
        }
    }
    pub struct SRefLock<'a, TField, T: A> {
        _guard: RwLockReadGuard<'a, SCore<T>>,
        reference: &'a TField,
    }
    impl<'a, TField, T: A> SRefLock<'a, TField, T> {
        fn new(ptr: *const TField, guard: RwLockReadGuard<'a, SCore<T>>) -> Self {
            let reference = unsafe { &*ptr };
            return Self { _guard: guard, reference };
        }
    }
    impl<'a, TField, T: A> Deref for SRefLock<'a, TField, T> {
        type Target = TField;
        fn deref(&self) -> &Self::Target {
            return self.reference;
        }
    }
    pub struct SMutLock<'a, TField, T: A> {
        _guard: RwLockWriteGuard<'a, SCore<T>>,
        reference: &'a TField,
        reference_mutable: &'a mut TField,
    }
    impl<'a, TField, T: A> SMutLock<'a, TField, T> {
        fn new(ptr: *mut TField, guard: RwLockWriteGuard<'a, SCore<T>>) -> Self {
            let reference = unsafe { &*ptr };
            let reference_mutable = unsafe { &mut *ptr };
            return Self {
                _guard: guard,
                reference,
                reference_mutable,
            };
        }
    }
    impl<'a, TField, T: A> Deref for SMutLock<'a, TField, T> {
        type Target = TField;
        fn deref(&self) -> &Self::Target {
            return self.reference;
        }
    }
    impl<'a, TField, T: A> DerefMut for SMutLock<'a, TField, T> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            return self.reference_mutable;
        }
    }
}
