// ðŸ¦€ Generated by Rust Macro Expand ðŸ¦€
// ðŸ¦€ Timestamp: 07/10/2023, 15:35:21  ðŸ¦€

pub mod with_into_impl {
    use std::ops::Range;
    use warcrwlock::warcrwlock;
    pub type Core = _core::Number;
    use std::{
        fmt::Debug, ops::{Deref, DerefMut},
        sync::{Arc, RwLock, RwLockReadGuard, RwLockWriteGuard},
    };
    mod _core {
        #[doc(hidden)]
        pub struct Number {
            pub(super) number: usize,
        }
    }
    #[repr(C)]
    pub struct Number {
        _core: Arc<RwLock<Core>>,
    }
    impl Number {
        pub fn number_mut(&mut self) -> NumberMutLock<usize> {
            let mut guard = self._core.write().unwrap();
            let value = &mut guard.number;
            let value = (value as *const usize) as *mut usize;
            return NumberMutLock::new(value, guard);
        }
        pub fn number(&self) -> NumberRefLock<usize> {
            let guard = self._core.read().unwrap();
            let value = &guard.number;
            let value = value as *const usize;
            return NumberRefLock::new(value, guard);
        }
        fn builder(number: usize) -> Self {
            return Core { number }.into();
        }
    }
    impl Number {
        pub fn extract(&self) -> Core {
            self.clone().into()
        }
    }
    impl From<Number> for Core {
        fn from(wrapper: Number) -> Self {
            let guard = wrapper._core.write().unwrap();
            let ptr = &*guard as *const Core;
            let reply = unsafe { std::ptr::read(ptr) };
            drop(guard);
            return reply;
        }
    }
    impl<'a> From<Core> for Number {
        fn from(_core: Core) -> Self {
            return Self {
                _core: Arc::new(RwLock::new(_core)),
            };
        }
    }
    impl PartialEq for Number {
        fn eq(&self, other: &Self) -> bool {
            let ptr_number = self._core.as_ref() as *const RwLock<Core> as usize;
            let other_ptr_number = other._core.as_ref() as *const RwLock<Core> as usize;
            return ptr_number == other_ptr_number;
        }
    }
    impl Clone for Number {
        fn clone(&self) -> Self {
            return Self { _core: self._core.clone() };
        }
    }
    unsafe impl Send for Number {}
    unsafe impl Sync for Number {}
    impl Number {
        fn into_vec_wrapper(bases: Vec<Core>) -> Vec<Number> {
            bases.into_iter().map(|b| b.into()).collect()
        }
        fn into_vec_base(multiples: Vec<Number>) -> Vec<Core> {
            multiples.iter().map(|w| (*w).clone().into()).collect()
        }
    }
    pub struct NumberRefLock<'a, T> {
        _guard: RwLockReadGuard<'a, Core>,
        reference: &'a T,
    }
    impl<'a, T> NumberRefLock<'a, T> {
        fn new(ptr: *const T, guard: RwLockReadGuard<'a, Core>) -> Self {
            let reference = unsafe { &*ptr };
            return Self { _guard: guard, reference };
        }
    }
    impl<'a, T> Deref for NumberRefLock<'a, T> {
        type Target = T;
        fn deref(&self) -> &Self::Target {
            return self.reference;
        }
    }
    pub struct NumberMutLock<'a, T> {
        _guard: RwLockWriteGuard<'a, Core>,
        reference: &'a T,
        reference_mutable: &'a mut T,
    }
    impl<'a, T> NumberMutLock<'a, T> {
        fn new(ptr: *mut T, guard: RwLockWriteGuard<'a, Core>) -> Self {
            let reference = unsafe { &*ptr };
            let reference_mutable = unsafe { &mut *ptr };
            return Self {
                _guard: guard,
                reference,
                reference_mutable,
            };
        }
    }
    impl<'a, T> Deref for NumberMutLock<'a, T> {
        type Target = T;
        fn deref(&self) -> &Self::Target {
            return self.reference;
        }
    }
    impl<'a, T> DerefMut for NumberMutLock<'a, T> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            return self.reference_mutable;
        }
    }
    mod _into_0 {
        use super::*;
        use super::Core as Number;
        impl Number {
            pub(super) fn new(number: usize) -> Self {
                Number { number }
            }
            pub(super) fn insert(&mut self, value: usize) {
                self.number += value;
            }
            pub(super) fn multiply(
                &mut self,
                other: &mut RwLockWriteGuard<Self>,
            ) -> &mut Self {
                self.number *= other.number;
                other.number *= self.number;
                self
            }
            pub(super) fn full_method(
                &mut self,
                other: &mut RwLockWriteGuard<Self>,
            ) -> Self {
                let reply = Number::new(self.number + other.number);
                reply
            }
            pub(super) fn full_method_mut_ref(&mut self, other: &mut usize) -> Self {
                let reply = Number::new(self.number + *other);
                *other *= self.number;
                reply
            }
            pub(super) fn ref_value(&self) -> &usize {
                &self.number
            }
            pub(super) fn mut_value(&mut self) -> &mut usize {
                &mut self.number
            }
            pub(super) fn set_value(&mut self, value: usize) -> &mut Self {
                self.number = value;
                self
            }
        }
    }
    impl Number {
        fn new(number: usize) -> Self {
            let reply = Core::new(number).into();
            return reply;
        }
        pub fn insert(&mut self, value: usize) {
            let mut guard = self._core.write().unwrap();
            guard.insert(value);
        }
        pub fn multiply(&mut self, other: &mut Self) -> &mut Self {
            let mut guard = self._core.write().unwrap();
            let other = &mut other._core.write().unwrap();
            guard.multiply(other);
            drop(guard);
            return self;
        }
        fn full_method(&mut self, other: &mut Self) -> Self {
            let mut guard = self._core.write().unwrap();
            let other = &mut other._core.write().unwrap();
            let reply = guard.full_method(other).into();
            return reply;
        }
        pub fn full_method_mut_ref(&mut self, other: &mut usize) -> Self {
            let mut guard = self._core.write().unwrap();
            let reply = guard.full_method_mut_ref(other).into();
            return reply;
        }
        pub fn ref_value(&self) -> NumberRefLock<usize> {
            let guard = self._core.read().unwrap();
            let value = guard.ref_value();
            let value = value as *const usize;
            return NumberRefLock::new(value, guard);
        }
        pub fn mut_value(&mut self) -> NumberMutLock<usize> {
            let mut guard = self._core.write().unwrap();
            let value = guard.mut_value();
            let value = (value as *const usize) as *mut usize;
            return NumberMutLock::new(value, guard);
        }
        pub fn set_value(&mut self, value: usize) -> &mut Self {
            let mut guard = self._core.write().unwrap();
            guard.set_value(value);
            drop(guard);
            return self;
        }
    }
    impl Number {
        pub fn push_one(&mut self) {
            *self.number_mut() += 1;
        }
        pub fn sequencial_numbers(range: Range<usize>) -> Vec<Self> {
            let mut reply = Vec::new();
            for index in range {
                reply.push(Self::new(index))
            }
            reply
        }
    }
}
