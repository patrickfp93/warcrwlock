// ðŸ¦€ Generated by Rust Macro Expand ðŸ¦€
// ðŸ¦€ Timestamp: 18/10/2023, 19:44:46  ðŸ¦€

pub mod with_generics {
    use warcrwlock::warcrwlock;
    pub type GenericCore<T: PartialEq> = _core::Generic<T>;
    use std::{
        fmt::Debug, ops::{Deref, DerefMut},
        sync::{Arc, RwLock, RwLockReadGuard, RwLockWriteGuard},
    };
    mod _core {
        use super::*;
        #[doc(hidden)]
        pub struct Generic<T: PartialEq> {
            pub(super) value: T,
        }
    }
    #[repr(C)]
    pub struct Generic<T: PartialEq> {
        _core: Arc<RwLock<GenericCore<T>>>,
    }
    impl<T: PartialEq> Generic<T> {
        fn value_mut(&mut self) -> GenericMutLock<T, T> {
            let mut guard = self._core.write().unwrap();
            let value = &mut guard.value;
            let value = (value as *const T) as *mut T;
            return GenericMutLock::new(value, guard);
        }
        fn value(&self) -> GenericRefLock<T, T> {
            let guard = self._core.read().unwrap();
            let value = &guard.value;
            let value = value as *const T;
            return GenericRefLock::new(value, guard);
        }
        fn builder(value: T) -> Self {
            return GenericCore::<T> { value }.into();
        }
    }
    impl<T: PartialEq> Generic<T> {
        pub fn extract(&self) -> GenericCore<T> {
            self.clone().into()
        }
    }
    impl<T: PartialEq> From<Generic<T>> for GenericCore<T> {
        fn from(wrapper: Generic<T>) -> Self {
            let guard = wrapper._core.write().unwrap();
            let ptr = &*guard as *const GenericCore<T>;
            let reply = unsafe { std::ptr::read(ptr) };
            drop(guard);
            return reply;
        }
    }
    impl<'a, T: PartialEq> From<GenericCore<T>> for Generic<T> {
        fn from(_core: GenericCore<T>) -> Self {
            return Self {
                _core: Arc::new(RwLock::new(_core)),
            };
        }
    }
    impl<T: PartialEq> PartialEq for Generic<T> {
        fn eq(&self, other: &Self) -> bool {
            let ptr_number = self._core.as_ref() as *const RwLock<GenericCore<T>>
                as usize;
            let other_ptr_number = other._core.as_ref() as *const RwLock<GenericCore<T>>
                as usize;
            return ptr_number == other_ptr_number;
        }
    }
    impl<T: PartialEq> Clone for Generic<T> {
        fn clone(&self) -> Self {
            return Self { _core: self._core.clone() };
        }
    }
    unsafe impl<T: PartialEq> Send for Generic<T> {}
    unsafe impl<T: PartialEq> Sync for Generic<T> {}
    impl<T: PartialEq> Generic<T> {
        fn into_vec_wrapper(bases: Vec<GenericCore<T>>) -> Vec<Generic<T>> {
            bases.into_iter().map(|b| b.into()).collect()
        }
        fn into_vec_base(multiples: Vec<Generic<T>>) -> Vec<GenericCore<T>> {
            multiples.iter().map(|w| (*w).clone().into()).collect()
        }
    }
    pub struct GenericRefLock<'a, TField, T: PartialEq> {
        _guard: RwLockReadGuard<'a, GenericCore<T>>,
        reference: &'a TField,
    }
    impl<'a, TField, T: PartialEq> GenericRefLock<'a, TField, T> {
        fn new(ptr: *const TField, guard: RwLockReadGuard<'a, GenericCore<T>>) -> Self {
            let reference = unsafe { &*ptr };
            return Self { _guard: guard, reference };
        }
    }
    impl<'a, TField, T: PartialEq> Deref for GenericRefLock<'a, TField, T> {
        type Target = TField;
        fn deref(&self) -> &Self::Target {
            return self.reference;
        }
    }
    pub struct GenericMutLock<'a, TField, T: PartialEq> {
        _guard: RwLockWriteGuard<'a, GenericCore<T>>,
        reference: &'a TField,
        reference_mutable: &'a mut TField,
    }
    impl<'a, TField, T: PartialEq> GenericMutLock<'a, TField, T> {
        fn new(ptr: *mut TField, guard: RwLockWriteGuard<'a, GenericCore<T>>) -> Self {
            let reference = unsafe { &*ptr };
            let reference_mutable = unsafe { &mut *ptr };
            return Self {
                _guard: guard,
                reference,
                reference_mutable,
            };
        }
    }
    impl<'a, TField, T: PartialEq> Deref for GenericMutLock<'a, TField, T> {
        type Target = TField;
        fn deref(&self) -> &Self::Target {
            return self.reference;
        }
    }
    impl<'a, TField, T: PartialEq> DerefMut for GenericMutLock<'a, TField, T> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            return self.reference_mutable;
        }
    }
    mod _into_1 {
        use super::*;
        use super::GenericCore as Generic;
        impl<T: PartialEq> Generic<T> {
            pub(super) fn new(value: T) -> Self {
                Self { value }
            }
        }
    }
    impl<T: PartialEq> Generic<T> {
        pub fn new(value: T) -> Self {
            let reply = GenericCore::new(value).into();
            return reply;
        }
    }
}
